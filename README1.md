**Анализ алгоритма: Сортировка выбором (Selection Sort)**
  
  **Определение:**
    Сортировка выбором — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и     меняет его местами с первым элементом этой части.
  
  **Анализ:**
  Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.
Внешний цикл for выполняется n-1 раз.
Внутренний цикл for в худшем случае выполняется n-1, затем n-2, ..., раз за каждый проход внешнего цикла.
Общее количество сравнений примерно равно n*(n-1)/2.

  **Временная сложность: O(n²)**,  где n - длина массива.
  
  **Почему O(n²):** Внешний цикл выполняется примерно n раз. Для каждого шага внешнего цикла внутренний цикл тоже выполняется примерно n раз, начиная с i + 1, что что приводит к квадратичной зависимости.
  ______________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка обменом (пузырьком)**
  
  **Определение:**
    Сортировка обменом (или пузырьковая сортировка) — это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке.
  
  **Анализ:**
    Алгоритм проходит по массиву, сравнивая соседние элементы и меняя их местами, если левый больше правого. Это "всплывание" самого большого элемента в конец.
    Внешний цикл for выполняется n-1 раз.
    Внутренний цикл for в худшем случае (когда массив отсортирован в обратном порядке) выполняется n-1, затем n-2, ..., раз.
    Оптимизация с флагом swapped позволяет выйти из цикла раньше, если массив уже отсортирован.

  **Временная сложность: O(n²)**,  где n - длина массива.

  **Почему она именно такая?**
    Внешний цикл for i in range(n) выполняется примерно n раз.
    Для каждого прохода внутренний цикл for j in range(0, n - i - 1) выполняется примерно (n - i - 1) раз.
    В сумме получается примерно n + (n-1) + (n-2) + ... + 1, что равно арифметической прогрессии.
    Поэтому асимптотическая сложность — O(n²).
___________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка вставками**

  **Определение:**
    Сортировка вставками — это алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.

  **Анализ:**
      Алгоритм строит отсортированную часть списка, начиная с первого элемента. Каждый новый элемент вставляется в правильное место среди уже отсортированных.
Внешний цикл for проходит по n-1 элементам.
Внутренний цикл while в худшем случае (массив отсортирован в обратном порядке) может выполнить до i итераций на i-ой итерации внешнего цикла.

  **Временная сложность: O(n log n)**, где n — размер массива.

   **Почему она именно такая?**
     На каждом уровне рекурсии в сумме при слиянии обрабатывается весь массив (размером (n)).
Так как уровней примерно (log_2 n), то итоговая сложность — O(n log n)
_________________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка Шелла**

  **Определение:**
    Сортировка Шелла — это алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.
  **Анализ:**
    Это модификация сортировки вставками. Она сначала сортирует элементы, находящиеся на определенном расстоянии (gap), затем уменьшает gap и повторяет процесс.
Выбор последовательности gap (например, n/2, n/4, ..., 1) влияет на производительность.
  
  **Временная сложность:**

  **Почему она именно такая?**

_______________________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Быстрая сортировка**
  
  **Определение:**
    Быстрая сортировка — это эффективный алгоритм сортировки, который использует принцип «разделяй и властвуй».
  
  **Анализ:**
    Выбирается опорный элемент. Массив перераспределяется так, что элементы, меньшие или равные опорному, оказываются слева от него, а большие — справа.
    Затем рекурсивно сортируются левая и правая части.
    Выбор опорного элемента критичен для производительности.
  
  **Временная сложность:**

  **Почему она именно такая?**
__________________________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Пирамидальная сортировка (Heap Sort)**
  
  **Определение:**
    Пирамидальная сортировка — это алгоритм сортировки сравнением, который использует структуру данных двоичная куча.
  
  **Анализ:**
    Сначала строится max-heap (бинарное дерево, где родитель >= детей).
    Затем максимальный элемент (корень) извлекается и помещается в конец массива. Куча уменьшается, и свойство heap восстанавливается для оставшейся части.
  
  **Временная сложность:**

  **Почему она именно такая?**
__________________________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Последовательный (линейный) поиск**
  
  **Определение:**
    Последовательный (линейный) поиск — это простой алгоритм, который поочередно проверяет каждый элемент в наборе данных, пока не будет найден искомый элемент или не будет пройден весь список.
  
  **Анализ:**
    Алгоритм последовательно просматривает элементы массива, сравнивая их с искомым значением.

  **Временная сложность:**

  **Почему она именно такая?**
__________________________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Бинарный поиск**
  
  **Определение:**
    Бинарный поиск — это алгоритм для поиска элемента в отсортированном массиве.
  
  **Анализ:**
    Алгоритм работает только с отсортированным массивом.
    На каждом шаге область поиска уменьшается вдвое за счет сравнения с элементом в середине.

  **Временная сложность:**

  **Почему она именно такая?**
__________________________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Интерполирующий поиск**
  
  **Определение:**
    Интерполирующий поиск — это алгоритм поиска значения в упорядоченном массиве чисел, который работает быстрее бинарного поиска при равномерном распределении данных.
  
  **Анализ:**
    Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.

  **Временная сложность:**

  **Почему она именно такая?**
__________________________________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Поиск по Фибоначчи**
  
  **Определение:**
    Поиск методом Фибоначчи — это итеративный алгоритм для поиска экстремума (минимума или максимума) унимодальной функции на заданном интервале, а также метод поиска нужного значения в отсортированном массиве.
  
  **Анализ:**
    Использует числа Фибоначчи для определения точек разбиения массива, аналогично бинарному поиску (деление на части), но с разными пропорциями.

  **Временная сложность:**

  **Почему она именно такая?**

















