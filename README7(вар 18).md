**Вариант 18. Табу-поиск для раскраски графа**
----------------------------------------------------------------------------------------------
Задача: 
реализовать Табу-поиск для задачи раскраски графа.

Требования:
- Использовать табу-лист для хранения последних изменений цветов
- Итерации поиска: 500
- Размер табу-листа: 10
- Вывести финальное количество цветов и распределение

Входные данные: Граф с 12 вершинами
_______________________________________________________________________________________________  
**Анализ:**

Код имеет четкую модульную структуру, разделенную на три основных компонента:

1. Функция-драйвер (find_min_coloring):
    - Эта функция управляет общей стратегией.
  
    - Она итеративно уменьшает $k$ (количество цветов) и вызывает ядро алгоритма для каждой $k$, чтобы найти минимальное $k$, при котором возможно 0 конфликтов.
  
2. Ядро алгоритма (tabu_search_k_coloring):

   - Здесь реализована сама метаэвристика Табу-поиска для фиксированного $k$.

   - Она содержит основной цикл (500 итераций) 9, логику поиска по окрестности, управление tabu_list 10и критерий аспирации11.

3. Вспомогательная функция (count_conflicts):

   - Это "фитнес-функция" (оценка качества). Она изолирует логику подсчета конфликтов, делая основной алгоритм чище.

Для хранения данных используются:
  - Граф: list[list] (список смежности) — эффективно для неполных графов.
  - Раскраска: list (массив), где индекс — вершина, значение — цвет.
  - Табу-лист: collections.deque(maxlen=10) — идеальная структура для FIFO-очереди (первый вошел, первый вышел) с фиксированным размером.
__________________________________________________________________________________________________________________________
**Временная сложность:** 

Она равна -> O(MAX_ITERATIONS × V × k)

где:
                                              
  -(V) — число вершин графа
                                              
  -(k) — число цветов

  -MAX_ITERATIONS — максимально допустимое число итераций алгоритма.

**Обоснование:**

В каждом из MAX_ITERATIONS проходов выполняется перебор всех вершин графа — O(V).

Для каждой вершины рассматриваются все возможные цвета, кроме текущего — O(k).

Внутри этого перебора выполняется простая проверка и обновление переменных — O(1).

Следовательно, суммарная сложность равна произведению этих составляющих:O(MAX_ITERATIONS × V × k)












  
