**Тема 1.2. Структуры данных. Работа в VS Code со структурами данных
  «мультисписок/очередь/дек/приоритетная очередь»**
-----------------------------------------------------------------------------------------------
* **Мультисписок-** 
это структура данных, которая позволяет упростить организацию нескольких списков с одинаковыми элементами. Мультисписок состоит из элементов с таким числом указателей, которое позволяет организовать их одновременно в виде нескольких различных списков. За счёт отсутствия дублирования данных память используется более рационально.

* **Очередь-**
это структура данных, которая обеспечивает FIFO-порядок элементов: чем раньше был добавлен элемент в коллекцию, тем раньше он из неё удаляется. Это стандартная модель однонаправленной очереди. Бывают и двунаправленные очереди, в которых можно добавить элемент не только в начало, но и в конец, и удалить не только из конца, но и из начала.

* **Дек-**
это упорядоченная последовательность элементов, в которой включение и исключение элемента могут выполняться в обоих концах. Дек является обобщением очереди и стека. Назначение дека — переупорядочивание поступающих данных перед обработкой.

* **Приоритетная очередь-**
это коллекция элементов, где каждый элемент имеет связанный с ним приоритет. Элемент с высшим приоритетом будет обрабатываться раньше, чем элементы с более низким приоритетом. В приоритетной очереди указывается приоритет поступающего элемента. При удалении из очереди выбирается элемент с наивысшим приоритетом (или один из таких элементов), а не тот, который поступил первым.

_____________________________________________________________________________________________
**Мультисписок:**
---------------------------------------------------------------------------------------------
Особенности реализации:

Python: Используются стандартные списки (list), которые могут содержать другие списки. Обработка, как правило, происходит с помощью вложенных циклов for.

C++: Документ предлагает ручную реализацию через структуру Node, содержащую данные и указатели prev (на предыдущий) и next (на следующий элемент).

Java: Упоминается два подхода: использование встроенного класса LinkedList из Java Collections или ручное создание собственных классов Node и DoublyLinkedList.
________________________________________________________________________________________________
**Очередь:**
----------------------------------------------------------------------------------------------------
Особенности реализации:
Python:

Очередь: Можно использовать класс Queue из модуля queue  (методы put() для добавления, get() для извлечения ) или класс deque из модуля collections.

C++:

Очередь: Класс std::queue<T>. Методы push() (добавить) , pop() (удалить) , front() (получить первый), back() (получить последний).

Java:

Очередь: Интерфейс Queue, часто реализуемый классом LinkedList. Методы add() (добавить) , poll() (удалить и вернуть) , peek() (посмотреть без удаления).

Ключевое различие — в именах классов и методах для одних и тех же операций.
________________________________________________________________________________________________
**Дек:**
----------------------------------------------------------------------------------------------------
Python:

Дек: Используется класс deque из collections. Методы append() (добавить в конец) и popleft() (удалить из начала).

C++:

Дек: Класс std::deque<T>. Методы push_back() (добавить в конец) и push_front() (добавить в начало).

Java:

Дек: Интерфейс Deque, часто реализуемый классом ArrayDeque. Методы push() (добавить в начало) и pop() (удалить из начала).
____________________________________________________________________________________________________
**Приоритетная очередь:**
-----------------------------------------------------------------------------------------------

Python:

Можно использовать класс PriorityQueue из модуля queue. Элементы добавляются кортежами (приоритет, данные).

Также можно использовать модуль heapq с функциями heappush() и heappop().

C++:

Используется класс std::priority_queue<T>.

По умолчанию это max-heap — первым извлекается элемент с наибольшим значением (наивысшим приоритетом).

Для работы с пользовательскими структурами (например, Task) необходимо перегрузить оператор <.

Java:

Используется класс java.util.PriorityQueue.

По умолчанию это min-heap — элементы упорядочены в "естественном порядке", то есть первым извлекается наименьший элемент.

Для настройки порядка (например, для max-heap или пользовательских объектов) в конструктор передается Comparator.

Итог по различиям:

Поведение по умолчанию: C++ (std::priority_queue) — это max-heap , а Java (PriorityQueue) — это min-heap.

Кастомизация: В C++ для пользовательских типов используется перегрузка оператора , в Java — Comparator.

Реализация в Python: Предлагает два варианта — готовый класс PriorityQueue и модуль heapq для работы со списками.

















