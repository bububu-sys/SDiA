**Контрольные задания (по вариантам)**
---------------------------------------------------------------------
**Задание 2. Метод ближайшего соседа (TSP)**

Условие. 

Дан граф городов с расстояниями. Найти приближённый маршрут коммивояжёра,
стартуя из города 0.

Алгоритм: ближайший сосед.

Язык примера: Java

"

public static List<Integer> tspNearest(int[][] dist) {
 
 List<Integer> path = new ArrayList<>();
 
 boolean[] visited = new boolean[dist.length];
 
 int curr = 0;
 
 path.add(curr);
 
 visited[curr] = true;
 
 // ДОПИСАТЬ: цикл выбора ближайшего непосещённого города
 
 return path;

}

"

Что дописать: цикл по всем городам с выбором минимума.
__________________________________________________________________________________
**Алгоритм выполнения задачи**
-----------------------------------------------------------
1) Инициализировать начальный город и добавить его в маршрут.

       path.add(curr);
2) Пока есть непосещенные города, найти ближайший к текущему.

       for (int j = 0; j < n; j++) {
3) Добавить найденный город в маршрут и пометить как посещенный.

        path.add(nextCity);
        visited[nextCity] = true;
4) Перейти к найденному городу как к текущему.

        curr = nextCity;
5) Повторять шаги 2-4 до посещения всех городов.

        for (int step = 1; step < n; step++) {
______________________________________________________________________________________
**Временная сложность:**  O(n²)

**Пояснение:** Для каждого из n городов мы просматриваем все n городов для поиска ближайшего непосещенного, что дает квадратичную сложность O(n²).
_________________________________________________________________________________________
**Контрольные вопросы**
------------------------------------------------------------------
1. Определение приближенных алгоритмов
   
Приближенный алгоритм — это алгоритм, который находит решение, близкое к оптимальному, но не гарантирует точное решение, особенно для NP-сложных задач.

2. Коэффициент аппроксимации

Для задачи минимизации: A(I) ≤ α × OPT(I), где α ≥ 1 характеризует максимальное отклонение от оптимума.

3. PTAS и FPTAS

PTAS — полиномиальная схема аппроксимации с временем работы, полиномиальным от размера входа; FPTAS — полностью полиномиальная схема, где время работы полиномиально и от размера входа, и от 1/ε.

4. Жадный алгоритм для вершинного покрытия
   
Алгоритм дает 2-аппроксимацию, так как каждое выбранное ребро требует минимум одну вершину в оптимальном решении, а мы выбираем две.

5. Жадный алгоритм для 0-1 рюкзака
   
Не гарантирует оптимальность, так как жадный выбор по удельной стоимости может исключить дорогой предмет, который входит в оптимальное решение.

6. Различие дробного и 0-1 рюкзака
    
В дробном рюкзаке можно брать части предметов, в 0-1 — только целые предметы.

7. Коэффициент аппроксимации для составления расписания
    
Доказывается через анализ максимальной загрузки машины: Cmax ≤ (2 - 1/m) × OPT.

8. Алгоритм Кристофидеса
    
Этапы: построение MST, паросочетание нечетных вершин, эйлеров цикл, сокращение; дает 1.5-аппроксимацию благодаря свойствам MST и паросочетания.

9. Жадный алгоритм для покрытия множеств
    
Имеет коэффициент аппроксимации H(n) ≈ ln n, так как на каждом шаге выбирает множество, покрывающее максимальное число непокрытых элементов.

10. Эвристические алгоритмы
    
Отличаются от приближенных отсутствием гарантированной точности; примеры: генетические алгоритмы, имитация отжига.

11. Имитация отжига
    
Принцип: вероятностный поиск с постепенным уменьшением температуры, позволяющий избегать локальных оптимумов.

12. Критерий Метрополиса
    
Формула: P(accept) = exp(-ΔE/T), означает вероятность принятия худшего решения для выхода из локального оптимума.

13. Табу-поиск
    
Табу-лист хранит недавние ходы для предотвращения циклов и исследования новых областей пространства решений.

14. Критерий аспирации
    
Условие для перекрытия табу-статуса, когда решение значительно улучшает текущее лучшее.

15. Локальный поиск
    
Локальный оптимум — решение, которое нельзя улучшить в окрестности; метаэвристики нужны для его преодоления.

16. Оператор соседства
    
Определяет множество решений, достижимых из текущего за один шаг; пример: 2-opt обмен в TSP.

17. Генетические алгоритмы
    
Основные операции: отбор (selection), кроссовер (crossover), мутация (mutation) для имитации эволюции.

18. NP-сложность
    
Приближенные алгоритмы используются, так как точное решение NP-сложных задач требует экспоненциального времени.

19. Точность и скорость
    
Компромисс: более точные алгоритмы обычно требуют больше времени выполнения.

20. Применение в практике
    
Примеры: логистика (TSP), планирование работ, сетевые маршрутизации, биоинформатика, машинное обучение.












