**Анализ алгоритма: Блочная (корзинная) сортировка**
  
  **Определение:**
    Блочная сортировка (bucket sort) — это алгоритм, который распределяет
    элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
    значений. После этого каждая корзина сортируется отдельно (либо тем же методом
    рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
    объединяются обратно в один массив.
  
  **Анализ:**
  
  Принцип работы:
    
    1. Определяется количество корзин (например, по диапазону значений элементов(len)).
    
    2. Каждый элемент помещается в корзину согласно функции распределения(for num in arr).
    
    3. Содержимое каждой корзины сортируется индивидуально(for bucket in buckets).
    
    4. Корзины соединяются в порядке увеличения диапазона.
    
    Особенности:
      Эффективна для равномерно распределённых числовых данных и может достигать линейной асимптотики O(n), 
      если размер корзин выбран удачно. 
      Однако эффективность сильно падает при неравномерном распределении данных.
  
  **Временная сложность: O(n)**,  где n - длина массива.
__________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Блинная сортировка**
  
  **Определение:**
    Блинная сортировка (pancake sort) — это метод, основанный на операции
    переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
    обменивают соседние элементы или выбирают опорные точки, здесь единственная
    разрешённая операция — переворот префикса массива до выбранного индекса.
  
  **Анализ:**
    
    1. Найти максимальный элемент в неотсортированной части массива(arr.index(max).
    
    2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым(arr[:max_idx + 1]).
    
    3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце(rr[:current_size]).
    
    4. Повторить процесс для оставшейся неотсортированной части массива.
    
    Особенности:
      Сложность алгоритма — O(n2). Он интересен теоретически и используется как пример нестандартных методов сортировки.

  
  **Временная сложность: O(n²)**,  где n - длина массива.
__________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка бусинами (гравитационная)**
  
  **Определение:**
    Сортировка бусинами (bead sort), также известная как гравитационная
    сортировка, моделирует естественное поведение бусин, падающих вниз под действием
    гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
    Диннин в 2002 году.
  
  **Анализ:**
    
    1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
      количество которых соответствует его значению.(beads)
    
    2. Бусины располагаются на «стержнях» (как на абаке)(for num in arr).
    
    3. Под действием «гравитации» бусины падают вниз.
    
    4. После оседания бусин строки считываются сверху вниз — получается
      отсортированный массив.(return sorted_arr)
    
    Особенности:
      Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
      O(n), но практическая — выше из-за ограничения на диапазон и реализацию.

  
  **Временная сложность: O(n)**,  где n - длина массива.
________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Поиск скачками (Jump Search)**
  
  **Определение:**
    Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
    которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
    быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
    диапазона.
  
  **Анализ:**
    
    1. Делится массив на блоки длины m=n.
    
    2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
      искомому.(while prev <...)
    
    3. Если найденный элемент больше искомого, выполняется линейный поиск в
      предыдущем блоке.(while)
    
    Особенности:
      В среднем сложность поиска O(n).
      Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное время.

  
  **Временная сложность: O(n)**,  где n - длина массива.
______________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Экспоненциальный поиск (Exponential Search)**
  
  **Определение:**
    Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
    быстро определить диапазон, в котором может находиться искомое значение, а затем
    применяет двоичный поиск в этом диапазоне
  
  **Анализ:**
    
    1. Проверяется первый элемент массива.
    
    2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
      пока не будет найден элемент, больше или равный искомому.
    
    3. На найденном диапазоне выполняется бинарный поиск.

    Особенности:
      Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с
      неизвестным размером или частичным доступом.

  
  **Временная сложность: O(log⁡ n)**,  где n - длина массива.
_______________________________________________________________________________________________________________________________________________________________________
**Анализ алгоритма: Тернарный поиск (Ternary Search)**
  
  **Определение:**
    Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
    бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
    экстремум функции (в зависимости от задачи).
  
  **Анализ:**
  
    1. Делится диапазон индексов на три части.
  
    2. Сравнивается искомый элемент с элементами на двух разделительных границах.
    
    3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети
        массива, где может находиться искомое значение.
    
    Особенности:
      Сложность также O(log ⁡n), но число сравнений на шаг выше, чем в двоичном поиске.
      Помимо массивов, тернарный поиск часто используется для нахождения минимума или
      максимума на унимодальных функциях.

  
  **Временная сложность: O(log ⁡n)**,  где n - длина массива.














  
