**Тема 1.3. Структуры данных. Работа со структурами данных
«бинарная_биноминальная куча/куча Фибоначчи/хеш-таблицы»**
---------------------------------------------------------------------------------------------------
* **Бинарная куча —**  это полное бинарное дерево, узлы которого представлены в виде элементов массива (списка). 

* **Биноминальная куча —** это набор биномиальных деревьев с двумя свойствами: 
  - Ключ каждой вершины не меньше ключа её родителя.
  - Все биномиальные деревья имеют разный размер.

* **куча Фибоначчи —** это набор деревьев, упорядоченных в соответствии со свойством неубывающей пирамиды: ключ каждого узла не меньше ключа его родительского узла.

* **Хеш-таблица —** это структура данных, реализующая интерфейс ассоциативного массива. Позволяет хранить пары «ключ, значение» и выполнять три операции: добавление новой пары, поиск и удаление пары по ключу. 
____________________________________________________________________________________________________
**Бинарная и Биномиальная куча**
-----------------------------------------------------------------------
Главное различие в том, что Python предлагает встроенный модуль для бинарной кучи, в то время как для C++ и Java в документе приводятся примеры полных, самостоятельно реализованных классов.

Python:

- Для работы с бинарной кучей используется модуль heapq.

- Этот модуль реализует min-heap (минимальную кучу), где родительский элемент всегда меньше дочерних.

- Для реализации max-heap (максимальной кучи) документ предлагает использовать инвертированные значения (например, -10 вместо 10).

- Основные функции: heapify() (превращает список в кучу), heappush() (добавляет элемент) и heappop() (извлекает минимальный элемент).

- Также возможна реализация собственного класса BinaryHeap.

C++:

- Документ приводит примеры реализации обеих структур в виде пользовательских классов.

- Для бинарной кучи показан шаблонный класс MinHeap, реализующий, как следует из названия, минимальную кучу.

- Для биномиальной кучи (которая является набором биномиальных деревьев ) также приводится полная реализация класса BinomialHeap с операциями Insert, Union (слияние) и Extract_Min.

Java:

- Как и в C++, документ демонстрирует пользовательские реализации классов для обеих куч.

- Реализация бинарной кучи (BinaryHeap) в документе отличается гибкостью: она может работать как max-heap или min-heap в зависимости от флага, переданного в конструктор.

- Реализация биномиальной кучи (BinomialHeap) также приведена в виде полного класса, поддерживающего операции слияния (meld), вставки, удаления и поиска минимума.
____________________________________________________________________________________________________
**Куча Фибоначчи**
-------------------------------------------------------------------------------------------
В этом пункте в документе наблюдается существенное терминологическое различие. Документ путает структуру данных «Куча Фибоначчи» (сложная приоритетная очередь) с алгоритмами для вычисления «чисел Фибоначчи» (математическая последовательность).

Python:

- Документ прямо утверждает, что в Python нет встроенной структуры «куча Фибоначчи».

- Вместо этого, он приводит примеры программ для печати ряда Фибоначчи (последовательности чисел) с использованием цикла for и рекурсии.

C++:

- Документ также отмечает, что нет встроенной «кучи Фибоначчи».

- Однако, в отличие от разделов Python и Java, здесь представлен код для настоящей структуры данных FibonacciHeap в виде C++ шаблона.

- Эта реализация поддерживает операции, характерные для этой структуры: insert, unite (объединение куч), extractMin (извлечение минимума), decreaseKey (уменьшение ключа) и deleteElement (удаление).

Java:

- Аналогично разделу Python, документ не описывает структуру данных «куча Фибоначчи».

- Вместо этого он описывает реализацию «Fibonacci Series» (последовательности чисел) с помощью рекурсивного алгоритма, который вычисляет n-е число Фибоначчи.
_________________________________________________________________________________________
**Хеш-таблицы**
--------------------------------------------------------------------------------
Все три языка предоставляют встроенные реализации хеш-таблиц, но используют разные названия и, согласно документу, имеют некоторые различия в реализации.

Python:

- Встроенная реализация хеш-таблицы — это тип данных dict (словарь).

- Документ особо отмечает, что ключами могут быть только хешируемые (неизменяемые) объекты; например, список (list) не может быть ключом.

- Также в документе показаны примеры создания собственных классов HashTable для демонстрации принципов их работы.

C++:

- В C++ хеш-таблица реализована в стандартной библиотеке (STL) как std::unordered_map.

- Документ отмечает, что std::unordered_map использует цепочечное хеширование (chaining) для обработки коллизий и не сохраняет порядок элементов.

- Пример ручной реализации также использует массив std::list (метод цепочек).

Java:

- В Java для хеш-таблиц используются классы Hashtable и HashMap.

- Hashtable отображает ключи на значения, при этом ни ключ, ни значение не могут быть null.

- HashMap реализует хеш-таблицу на основе массива односвязных списков (также метод цепочек).
_________________________________________________________________________________________________
**Итог по различиям:**

Кучи: Python предоставляет удобный модуль heapq (только min-heap) , в то время как для C++ и Java документ демонстрирует создание гибких, но сложных пользовательских классов.

Куча Фибоначчи: Документ показывает фундаментальное различие в подходах. Для C++ приводится реализация структуры данных , а для Python и Java — алгоритмы для вычисления числовой последовательности.

Хеш-таблицы: Все языки имеют встроенные реализации (dict в Python, unordered_map в C++, HashMap/Hashtable в Java). Документ указывает, что реализации C++ и Java используют метод цепочек для разрешения коллизий.
