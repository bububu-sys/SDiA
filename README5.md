**Тема 3.1-3.5. Алгоритмы. Работа с алгоритмами сортировки и поиска**
---------------------------------------------------------------------------------
- сортировка выбором;

- сортировка обменом (пузырек);

- сортировка вставками;

- сортировка слиянием;

- сортировка Шелла;

- быстрая сортировка;

- пирамидальная сортировка;

- последовательный поиск;

- бинарный поиск;

- интерполирующий поиск;

- Фибоначчи поиск,

написанные на одном из ЯП Python, C++ или Java.
___________________________________________________________________________________
**Анализ алгоритма: Сортировка выбором (Selection Sort)**
--------------------------------------------------------------------------------------
  **Определение:**
    
  Сортировка выбором — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и     меняет его местами с первым элементом этой части.
  
  **Анализ:**
  
  Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.
Внешний цикл for выполняется n-1 раз.
Внутренний цикл for в худшем случае выполняется n-1, затем n-2, ..., раз за каждый проход внешнего цикла.
Общее количество сравнений примерно равно n*(n-1)/2.

  **Временная сложность: O(n²)**,  где n - длина массива.
  
  **Почему O(n²):** 
  
  Внешний цикл выполняется примерно n раз. Для каждого шага внешнего цикла внутренний цикл тоже выполняется примерно n раз, начиная с i + 1, что что приводит к квадратичной зависимости.
  _____________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка обменом (пузырьком)**
-----------------------------------------------------------------------------------  
  **Определение:**
    
  Сортировка обменом (или пузырьковая сортировка) — это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке.
  
  **Анализ:**
    
  Алгоритм проходит по массиву, сравнивая соседние элементы и меняя их местами, если левый больше правого. Это "всплывание" самого большого элемента в конец.
  Внешний цикл for выполняется n-1 раз.
  Внутренний цикл for в худшем случае (когда массив отсортирован в обратном порядке) выполняется n-1, затем n-2, ..., раз.
    Оптимизация с флагом swapped позволяет выйти из цикла раньше, если массив уже отсортирован.

  **Временная сложность: O(n²)**,  где n - длина массива.

  **Почему она именно такая?**
    
  Внешний цикл for i in range(n) выполняется примерно n раз.
  Для каждого прохода внутренний цикл for j in range(0, n - i - 1) выполняется примерно (n - i - 1) раз.
  В сумме получается примерно n + (n-1) + (n-2) + ... + 1, что равно арифметической прогрессии.
  Поэтому асимптотическая сложность — O(n²).
______________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка вставками**
--------------------------------------------------------------------------------
  **Определение:**
    
  Сортировка вставками — это алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.

  **Анализ:**
      
  Алгоритм строит отсортированную часть списка, начиная с первого элемента. Каждый новый элемент вставляется в правильное место среди уже отсортированных.
Внешний цикл for проходит по n-1 элементам.
Внутренний цикл while в худшем случае (массив отсортирован в обратном порядке) может выполнить до i итераций на i-ой итерации внешнего цикла.

  **Временная сложность: O(n²)**, где n — размер массива.

   **Почему она именно такая?**
     
  Внешний цикл for (int i = 1; i < n; ++i) выполняется порядка n раз, так как он перебирает все элементы массива, начиная со второго.
  Внутренний цикл while в худшем случае может пройтись по всей уже отсортированной части массива, если массив отсортирован в обратном порядке, все элементы приходилось сдвигать по одному для вставки текущего элемента на своё место. Таким образом мы снова приходим к квадратичной зависимость.
______________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка слиянием (Merge Sort)**
-----------------------------------------------------------------------------------------------
  **Определение:**
    
  Сортировка слиянием (Merge Sort) — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке.

  **Анализ:**
    
  Алгоритм делит массив пополам рекурсивно до тех пор, пока не останутся подмассивы размером 1.
Затем он сливает эти подмассивы, создавая большие отсортированные подмассивы.
Это делается с помощью функции merge, которая объединяет два уже отсортированных подмассива.

  **Временная сложность: O(n log n)**, где n — размер массива.

   **Почему она именно такая?**
     
  На каждом уровне рекурсии в сумме при слиянии обрабатывается весь массив (размером (n)).
  Так как уровней примерно (log_2 n), то итоговая сложность — O(n log n)
______________________________________________________________________________________________________________
**Анализ алгоритма: Сортировка Шелла**
---------------------------------------------------------------------------------------
  **Определение:**
    
  Сортировка Шелла — это алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.
  **Анализ:**
    
  Это модификация сортировки вставками. Она сначала сортирует элементы, находящиеся на определенном расстоянии (gap), затем уменьшает gap и повторяет процесс.
Выбор последовательности gap (например, n/2, n/4, ..., 1) влияет на производительность.
  
  **Временная сложность:** O(n (log n)^2) или O(n^2) (зависит от последовательности шагов)

  **Почему она именно такая?** 
  
  Эффективность зависит от того, как уменьшается этот шаг. В коде шаг уменьшается вдвое (n/2, n/4, ...), что является O(log n) шагов. На каждом шаге выполняется сортировка вставками, что и определяет итоговую сложность.
______________________________________________________________________________________________________________
**Анализ алгоритма: Быстрая сортировка**
-----------------------------------------------------------------------------------------------
  **Определение:**
    
  Быстрая сортировка — это эффективный алгоритм сортировки, который использует принцип «разделяй и властвуй».
  
  **Анализ:**
    
  Выбирается опорный элемент. Массив перераспределяется так, что элементы, меньшие или равные опорному, оказываются слева от него, а большие — справа.
  Затем рекурсивно сортируются левая и правая части.
  Выбор опорного элемента критичен для производительности.
  
  **Временная сложность:** O(n log n)

  **Почему она именно такая?** 
  
  В среднем случае (O(n log n)) алгоритм на каждом шаге делит массив на две примерно равные части (log n уровней). Это происходит благодаря операции partition, которая просматривает 'n' элементов.
______________________________________________________________________________________________________________
**Анализ алгоритма: Пирамидальная сортировка (Heap Sort)**
-------------------------------------------------------------------------------------------  
  **Определение:**
    
  Пирамидальная сортировка — это алгоритм сортировки сравнением, который использует структуру данных двоичная куча.
  
  **Анализ:**
    
  Сначала строится max-heap (бинарное дерево, где родитель >= детей).
  Затем максимальный элемент (корень) извлекается и помещается в конец массива. Куча уменьшается, и свойство heap восстанавливается для оставшейся части.
  
  **Временная сложность:** O(n log n)

  **Почему она именно такая?** 
  
  Сложность складывается из двух этапов. Сначала "построение max-heap" из 'n' элементов (с помощью вызовов heapify), что занимает O(n) времени. Затем "последовательное извлечение максимального элемента" : этот цикл  выполняется 'n' раз. Каждое извлечение (обмен корня с последним элементом и вызов heapify ) занимает O(log n) времени (высота пирамиды).
______________________________________________________________________________________________________________
**Анализ алгоритма: Последовательный (линейный) поиск**
----------------------------------------------------------------------------------------------  
  **Определение:**
    
  Последовательный (линейный) поиск — это простой алгоритм, который поочередно проверяет каждый элемент в наборе данных, пока не будет найден искомый элемент или не будет пройден весь список.
  
  **Анализ:**
    
  Алгоритм последовательно просматривает элементы массива, сравнивая их с искомым значением.

  **Временная сложность:** O(n)

  **Почему она именно такая?** 
  
  В худшем случае алгоритму необходимо "последовательно сравнить" искомое значение с каждым элементом в массиве , пока элемент не будет найден или пока не будет достигнут конец массива. Количество операций прямо пропорционально 'n'.
______________________________________________________________________________________________________________
**Анализ алгоритма: Бинарный поиск**
-------------------------------------------------------------------------------------------------- 
  **Определение:**
    
  Бинарный поиск — это алгоритм для поиска элемента в отсортированном массиве.
  
  **Анализ:**
    
  Алгоритм работает только с отсортированным массивом.
    На каждом шаге область поиска уменьшается вдвое за счет сравнения с элементом в середине.

  **Временная сложность:** O(log n)

  **Почему она именно такая?** 
  
  Алгоритм работает только на отсортированных данных. Он "неоднократно делит" область поиска пополам. При каждом сравнении со средним элементом 37373737отбрасывается половина оставшихся данных. Количество раз, которое можно разделить 'n' элементов пополам, равно log n.
______________________________________________________________________________________________________________
**Анализ алгоритма: Интерполирующий поиск**
---------------------------------------------------------------------------------------  
  **Определение:**
    
  Интерполирующий поиск — это алгоритм поиска значения в упорядоченном массиве чисел, который работает быстрее бинарного поиска при равномерном распределении данных.
  
  **Анализ:**
    
  Похож на бинарный поиск, но вместо деления пополам, предполагает позицию элемента на основе его значения и значений на границах, предполагая равномерное распределение.

  **Временная сложность:** O(log log n)

  **Почему она именно такая?** 
  
  Вместо деления пополам, он "предсказывает" 41позицию элемента, используя формулу, основанную на значениях искомого элемента и границ. Если элементы "распределены равномерно", он сужает область поиска гораздо быстрее, чем log n.
______________________________________________________________________________________________________________
**Анализ алгоритма: Поиск по Фибоначчи**
----------------------------------------------------------------------------------------  
  **Определение:**
    
  Поиск методом Фибоначчи — это итеративный алгоритм для поиска экстремума (минимума или максимума) унимодальной функции на заданном интервале, а также метод поиска нужного значения в отсортированном массиве.
  
  **Анализ:**
    
  Использует числа Фибоначчи для определения точек разбиения массива, аналогично бинарному поиску (деление на части), но с разными пропорциями.

  **Временная сложность:** O(log n)

  **Почему она именно такая?** 
  
  Алгоритм "использует числа Фибоначчи"  для определения позиций сравнения. Он делит массив на части, размеры которых соответствуют последовательным числам Фибоначчи. На каждом шаге он отбрасывает часть массива и сужает поиск, используя следующую пару чисел Фибоначчи. Этот процесс деления области поиска является логарифмическим.

















