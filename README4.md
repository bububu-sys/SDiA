**Структуры данных. Работа со структурами данных «деревья/графы»**
------------------------------------------------------------------------------
**Анализ:**
_____________________________________________________________________________________
1. Деревья:

    -Во всех трех языках базовая структура для бинарного дерева реализуется через класс узла (Node или TNode), который содержит:

      - Ключ (значение узла).

      - Две ссылки/указателя на левого и правого потомка.

    -Основное различие заключается в том, как обрабатываются эти ссылки и управляется памятью.

    **Java**

     - Структура узла: Используется класс Node , часто как внутренний статический класс Tree.

     - Компоненты узла: Включает поле для ключа (например, int key ) и две ссылки на дочерние узлы: Node left и Node right.

     - Обработка "null": Ссылки на отсутствующих потомков по умолчанию имеют значение null.

    **C++** 

      - Структура узла: Используется класс TNode.

      - Компоненты узла: Включает поле для ключа (например, int Key ) и два указателя на дочерние узлы: TNode* Left и TNode* Right.

      Особености:

      - В документе подчеркивается, что для связывания вершин используются именно указатели, а не ссылки C++ (&), поскольку ссылки не могут быть нулевыми или переназначены.

      - Обработка "null": Указатели на отсутствующих потомков необходимо явно обнулять (используя 0, NULL или nullptr).

      - Управление памятью: Требуется явное управление памятью, например, класс TTree должен содержать деструктор для рекурсивного удаления всех узлов.

    **Python**

      - Структура узла: Используется класс Node.

      - Компоненты узла: Поля key, left и right обычно инициализируются в конструкторе __init__.

      - Обработка "null": Отсутствующие дочерние узлы представлены значением None.
_____________________________________________________________________________________
2. Графы

    Представление графов в документе в основном рассматривается в контексте реализации алгоритма Дейкстры  и демонстрирует два основных подхода: матрицу смежности и списки смежности.

    **Java**

      - Метод 1 (Матрица смежности): Граф представлен в виде двумерного массива (матрицы), где adjMat[i][j] хранит вес ребра между вершинами i и j (или 0, если ребра нет).

      - Метод 2 (Список смежности): Граф реализуется как массив списков (ArrayList<Edge>[] graph). Для работы алгоритма также используется очередь с приоритетами (PriorityQueue<Pair>).

    **C++**

      - Список смежности: Граф представлен с использованием vector<vector<Edge>>, где Edge — это структура, хранящая пункт назначения и вес.

      - Алгоритм: Использует priority_queue из стандартной библиотеки C++.

    **Python**

      - Список смежности (Словарь): Граф наиболее идиоматично представлен в виде вложенных словарей.
      Внешний словарь сопоставляет вершины со словарями их соседей, где ключами являются соседи, а значениями — веса ребер.

      - Алгоритм: Использует модуль heapq для реализации очереди с приоритетами.

